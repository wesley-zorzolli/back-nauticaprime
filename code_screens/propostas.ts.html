<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>propostas.ts</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
  <style>
    body{ background:#2b2b2b; color:#f8f8f2; font-family: 'Fira Code', monospace; padding:24px; }
    pre { font-size:14px; line-height:1.4; padding:20px; border-radius:8px; overflow:auto; }
    h1{ font-size:18px; color:#fff; margin-bottom:12px }
    .meta{ color:#bfbfbf; font-size:13px; margin-bottom:8px }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
</head>
<body>
  <h1>propostas.ts</h1>
  <div class="meta">path: C:\Users\wesle\OneDrive\Área de Trabalho\nautica_prime\back_nautica\routes\propostas.ts</div>
  <pre class="language-javascript"><code>import { PrismaClient } from "@prisma/client"
import { Router } from "express"
import { z } from 'zod'
import { getErrorMessage } from "../utils/errors"
import { sendMail } from '../services/mailer'
import { sendWhatsApp } from '../services/whatsappVenom'
import { sendWhatsAppTwilio } from '../services/whatsappTwilio'
import sendWhatsAppPuppeteer from '../services/whatsappPuppeteer'

const prisma = new PrismaClient()
const router = Router()

const propostaSchema = z.object({
  clienteId: z.string().uuid({
    message: "ID do cliente deve ser um UUID válido"
  }),
  embarcacaoId: z.number().int().positive({
    message: "ID da embarcação deve ser um número inteiro positivo"
  }),
  descricao: z.string().min(10, {
    message: "Descrição da proposta deve possuir, no mínimo, 10 caracteres"
  }).max(500, {
    message: "Descrição da proposta deve possuir, no máximo, 500 caracteres"
  })
})

// Listar todas as propostas (apenas para admins)
router.get("/", async (req, res) =&gt; {
  try {
    const propostas = await prisma.proposta.findMany({
      include: {
        cliente: {
          select: {
            id: true,
            nome: true,
            email: true,
            cidade: true
          }
        },
        embarcacao: {
          include: {
            marca: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
    return res.status(200).json(propostas)
  } catch (error) {
    return res.status(400).json({ erro: getErrorMessage(error, 'Erro ao listar propostas') })
  }
})

// Listar propostas de um cliente específico
router.get("/cliente/:clienteId", async (req, res) =&gt; {
  try {
    const { clienteId } = req.params

    const propostas = await prisma.proposta.findMany({
      where: {
        clienteId: clienteId
      },
      include: {
        embarcacao: {
          include: {
            marca: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
    return res.status(200).json(propostas)
  } catch (error) {
    return res.status(400).json({ erro: getErrorMessage(error, 'Erro ao listar propostas do cliente') })
  }
})

// Criar nova proposta
router.post("/", async (req, res) =&gt; {
  try {
    const validation = propostaSchema.safeParse(req.body)
    
    if (!validation.success) {
      const issues = validation.error.issues.map(issue =&gt; issue.message)
      return res.status(400).json({ erro: issues.join(', ') })
    }

    const { clienteId, embarcacaoId, descricao } = validation.data

    // Verificar se o cliente existe
    const clienteExiste = await prisma.cliente.findUnique({
      where: { id: clienteId }
    })
    
    if (!clienteExiste) {
      return res.status(404).json({ erro: "Cliente não encontrado" })
    }

    // Verificar se a embarcação existe
    const embarcacaoExiste = await prisma.embarcacao.findUnique({
      where: { id: embarcacaoId }
    })
    
    if (!embarcacaoExiste) {
      return res.status(404).json({ erro: "Embarcação não encontrada" })
    }

    // Verificar se já existe uma proposta pendente deste cliente para esta embarcação
    const propostaExistente = await prisma.proposta.findFirst({
      where: {
        clienteId: clienteId,
        embarcacaoId: embarcacaoId,
        status: "PENDENTE"
      }
    })

    if (propostaExistente) {
      return res.status(400).json({ erro: "Você já possui uma proposta pendente para esta embarcação" })
    }

    // Criar a proposta
    const novaProposta = await prisma.proposta.create({
      data: {
        clienteId,
        embarcacaoId,
        descricao,
        status: "PENDENTE"
      },
      include: {
        cliente: {
          select: {
            nome: true,
            email: true
          }
        },
        embarcacao: {
          include: {
            marca: true
          }
        }
      }
    })

    return res.status(201).json({
      sucesso: "Proposta criada com sucesso",
      proposta: novaProposta
    })
  } catch (error) {
    return res.status(500).json({ erro: getErrorMessage(error, 'Erro ao criar proposta') })
  }
})

// Atualizar status da proposta (apenas para admins)
router.patch("/:id/status", async (req, res) =&gt; {
  try {
    const { id } = req.params
    const { status } = req.body

    if (!status || !['PENDENTE', 'ACEITA', 'REJEITADA'].includes(status)) {
      return res.status(400).json({ erro: "Status inválido. Use: PENDENTE, ACEITA ou REJEITADA" })
    }

    const proposta = await prisma.proposta.findUnique({
      where: { id: Number(id) }
    })

    if (!proposta) {
      return res.status(404).json({ erro: "Proposta não encontrada" })
    }

    const propostaAtualizada = await prisma.proposta.update({
      where: { id: Number(id) },
      data: { status },
      include: {
        cliente: {
          select: {
            nome: true,
            email: true
          }
        },
        embarcacao: {
          include: {
            marca: true
          }
        }
      }
    })

    return res.status(200).json({
      sucesso: "Status da proposta atualizado com sucesso",
      proposta: propostaAtualizada
    })
  } catch (error) {
    return res.status(500).json({ erro: getErrorMessage(error, 'Erro ao atualizar status da proposta') })
  }
})

// Responder uma proposta (apenas para admins)
router.put("/:id/responder", async (req, res) =&gt; {
  try {
    const { id } = req.params
    const { resposta } = req.body

    if (!resposta || typeof resposta !== 'string' || resposta.trim().length &lt; 10) {
      return res.status(400).json({ erro: "Resposta deve ter pelo menos 10 caracteres" })
    }

    if (resposta.length &gt; 1000) {
      return res.status(400).json({ erro: "Resposta deve ter no máximo 1000 caracteres" })
    }

    const proposta = await prisma.proposta.findUnique({
      where: { id: Number(id) }
    })

    if (!proposta) {
      return res.status(404).json({ erro: "Proposta não encontrada" })
    }

    const propostaAtualizada = await prisma.proposta.update({
      where: { id: Number(id) },
      data: { 
        resposta: resposta.trim(),
        updatedAt: new Date()
      },
      include: {
        cliente: {
          select: {
            nome: true,
            email: true
          }
        },
        embarcacao: {
          include: {
            marca: true
          }
        }
      }
    })

    return res.status(200).json({
      sucesso: "Resposta enviada com sucesso",
      proposta: propostaAtualizada
    })
  } catch (error) {
    return res.status(500).json({ erro: getErrorMessage(error, 'Erro ao enviar resposta') })
  }
})

// Aceitar proposta e registrar venda (apenas para admins)
router.put("/:id/aceitar", async (req, res) =&gt; {
  try {
    const { id } = req.params
    const { valor_negociado, adminId } = req.body

    if (!valor_negociado || valor_negociado &lt;= 0) {
      return res.status(400).json({ erro: "Valor negociado deve ser maior que zero" })
    }

    if (!adminId) {
      return res.status(400).json({ erro: "ID do admin é obrigatório" })
    }

    // Verificar se o admin existe
    const adminExiste = await prisma.admin.findUnique({
      where: { id: adminId }
    })

    if (!adminExiste) {
      return res.status(404).json({ erro: "Admin não encontrado. Faça login novamente." })
    }

    const proposta = await prisma.proposta.findUnique({
      where: { id: Number(id) },
      include: {
        embarcacao: true,
        cliente: true
      }
    })

    if (!proposta) {
      return res.status(404).json({ erro: "Proposta não encontrada" })
    }

    if (proposta.status === "ACEITA") {
      return res.status(400).json({ erro: "Esta proposta já foi aceita" })
    }

    if (proposta.embarcacao.vendida) {
      return res.status(400).json({ erro: "Esta embarcação já foi vendida" })
    }

    // Usar transação para garantir consistência
    const resultado = await prisma.$transaction(async (tx) =&gt; {
      // 1. Atualizar status da proposta para ACEITA
      const propostaAtualizada = await tx.proposta.update({
        where: { id: Number(id) },
        data: { 
          status: "ACEITA",
          updatedAt: new Date()
        }
      })

      // 2. Criar registro de venda
      const venda = await tx.venda.create({
        data: {
          clienteId: proposta.clienteId,
          embarcacaoId: proposta.embarcacaoId,
          descricao: `Venda gerada a partir da proposta: ${proposta.descricao}`,
          valor: valor_negociado,
          data_venda: new Date(),
          adminId: adminId
        },
        include: {
          cliente: true,
          embarcacao: {
            include: {
              marca: true
            }
          }
        }
      })

      // 3. Marcar embarcação como vendida
      await tx.embarcacao.update({
        where: { id: proposta.embarcacaoId },
        data: { vendida: true }
      })

      // 4. Rejeitar todas as outras propostas desta embarcação
      await tx.proposta.updateMany({
        where: {
          embarcacaoId: proposta.embarcacaoId,
          id: { not: Number(id) },
          status: "PENDENTE"
        },
        data: { status: "REJEITADA" }
      })

      return { proposta: propostaAtualizada, venda }
    })

    // Enviar e-mail de confirmação para o cliente (se Mailtrap estiver configurado)
    try {
      if (process.env.MAILTRAP_USER &amp;&amp; process.env.MAILTRAP_PASS) {
        await sendMail({
          to: resultado.venda.cliente.email,
          subject: 'Sua proposta foi aceita! - Náutica Prime',
          html: `
            &lt;h2&gt;Olá, ${resultado.venda.cliente.nome}!&lt;/h2&gt;
            &lt;p&gt;&lt;strong&gt;Boa notícia!&lt;/strong&gt; Sua proposta foi aceita!&lt;/p&gt;
            &lt;h3&gt;Detalhes da venda:&lt;/h3&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;Embarcação:&lt;/strong&gt; ${resultado.venda.embarcacao.marca.nome} ${resultado.venda.embarcacao.modelo} (${resultado.venda.embarcacao.ano})&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;Descrição:&lt;/strong&gt; ${resultado.venda.descricao}&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;Valor negociado:&lt;/strong&gt; R$ ${Number(resultado.venda.valor).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;Data:&lt;/strong&gt; ${new Date(resultado.venda.data_venda).toLocaleDateString('pt-BR')}&lt;/li&gt;
            &lt;/ul&gt;
            &lt;p&gt;Em breve entraremos em contato para finalizar os detalhes da compra.&lt;/p&gt;
            &lt;p&gt;Obrigado por escolher a Náutica Prime!&lt;/p&gt;
          `
        })
      }
    } catch (emailError) {
      console.error('Erro ao enviar e-mail:', emailError)
      // Não interrompe o fluxo se o e-mail falhar
    }

    // Tentar enviar mensagem via WhatsApp (venom - solução local e grátis). Se falhar, tentar Twilio (fallback)
    try {
      const clienteTelefone = resultado.venda.cliente?.telefone
      if (clienteTelefone) {
        const mensagem = `Olá ${resultado.venda.cliente.nome}, sua proposta foi aceita!\nValor negociado: R$ ${Number(resultado.venda.valor).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}.\nEm breve entraremos em contato para os próximos passos.`
        try {
            // Primeiro: tenta Venom (se ativado)
            await sendWhatsApp(clienteTelefone, mensagem)
            console.log('Mensagem WhatsApp enviada via Venom para', clienteTelefone)
          } catch (venomErr) {
            console.warn('Falha ao enviar via Venom, tentando Puppeteer local/remoto fallback:', (venomErr as any)?.message || venomErr)
            // Segundo: tenta Puppeteer (Chrome remoto) — usa o browser que foi aberto em dev
            try {
              await sendWhatsAppPuppeteer(clienteTelefone, mensagem)
              console.log('Mensagem WhatsApp enviada via Puppeteer para', clienteTelefone)
            } catch (ppErr) {
              console.warn('Falha ao enviar via Puppeteer, tentando Twilio fallback:', (ppErr as any)?.message || ppErr)
              // Terceiro: Se Twilio estiver configurado, tente enviar por lá
              try {
                if (process.env.TWILIO_ACCOUNT_SID &amp;&amp; process.env.TWILIO_AUTH_TOKEN &amp;&amp; process.env.TWILIO_WHATSAPP_FROM) {
                  await sendWhatsAppTwilio(clienteTelefone, mensagem)
                  console.log('Mensagem WhatsApp enviada via Twilio para', clienteTelefone)
                } else {
                  console.log('Twilio não configurado; não foi possível enviar mensagem alternativa')
                }
              } catch (twErr) {
                console.error('Erro ao enviar via Twilio fallback:', twErr)
              }
            }
          }
      } else {
        console.log('Cliente não possui telefone cadastrado — pulando envio de WhatsApp')
      }
    } catch (waError) {
      console.error('Erro no fluxo de envio de WhatsApp:', waError)
      // Não interrompe o fluxo principal se o envio falhar
    }

    return res.status(200).json({
      sucesso: "Proposta aceita e venda registrada com sucesso",
      ...resultado
    })
  } catch (error) {
    return res.status(500).json({ erro: getErrorMessage(error, 'Erro ao aceitar proposta') })
  }
})

// Deletar proposta
router.delete("/:id", async (req, res) =&gt; {
  try {
    const { id } = req.params

    const proposta = await prisma.proposta.findUnique({
      where: { id: Number(id) }
    })

    if (!proposta) {
      return res.status(404).json({ erro: "Proposta não encontrada" })
    }

    await prisma.proposta.delete({
      where: { id: Number(id) }
    })

    return res.status(200).json({ sucesso: "Proposta deletada com sucesso" })
  } catch (error) {
    return res.status(500).json({ erro: getErrorMessage(error, 'Erro ao deletar proposta') })
  }
})

export default router</code></pre>
</body>
</html>